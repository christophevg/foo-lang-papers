\documentclass[conference]{IEEEtran}
\usepackage[pdftex]{graphicx}
\usepackage[cmex10]{amsmath}
\interdisplaylinepenalty=2500
% \usepackage{algorithmic}
\usepackage{array}
\usepackage{mdwmath}
\usepackage{mdwtab}
\usepackage{eqparbox}
\usepackage[font=footnotesize]{subfig}
\usepackage{fixltx2e}
\usepackage{url}
\hyphenation{}

% additional packages and utility commands
\usepackage{minted}
\usepackage{flushend}

% while preparing, linenumbers come in handy
\usepackage{lineno}
\setlength\linenumbersep{1mm}
\linenumbers

% until we settle on the final name ;-)
\usepackage{xspace}
\newcommand{\NAME}{id-foo\xspace}

% http://tex.stackexchange.com/questions/299/how-to-get-long-texttt-sections-to-break
\newcommand*\justify{%
  \fontdimen2\font=0.4em% interword space
  \fontdimen3\font=0.2em% interword stretch
  \fontdimen4\font=0.1em% interword shrink
  \fontdimen7\font=0.1em% extra space
  \hyphenchar\font=`\-% allowing hyphenation
}

% http://en.wikibooks.org/wiki/LaTeX/Customizing_LaTeX
\newcommand{\ttt}[1]{\texttt{\justify{#1}}}

\usepackage{algpseudocode}
% custom Let command
\newcommand*\Let[2]{\State #1 $\gets$ #2}
\renewcommand{\algorithmicforall}{\textbf{for each}}
\let\ForEach\ForAll

\begin{document}

% to avoid syntax error highlighting - e.g. foo's not js ;-)
\expandafter\def\csname PY@tok@err\endcsname{}

\title{
Introducing the \NAME Framework\\
for Efficient Intrusion Detection\\
in the Internet of Things
}

\author{\IEEEauthorblockN{Christophe Van Ginneken, Jef Maerien, Christophe
Huygens, Danny Hughes, Wouter Joosen}%
\IEEEauthorblockA{iMinds-DistriNet, KU Leuven\\
3001 Leuven, Belgium\\
\{firstname.lastname\}@cs.kuleuven.be}}

\maketitle

\begin{abstract}

Supporting multiple intrusion detection (ID) algorithms imposes significant
overhead on Internet of Things (IoT) devices. Fusion of the underlying
algorithms can alleviate this, yet, proves to be time-consuming, repetitive and
error-prone. To address this problem we introduce \NAME, a framework for the
development of efficient intrusion detection systems (IDS). It consists of a
domain specific language (DSL) that allows formally describing ID algorithms on
a functional level. A code generator then fuses these algorithms and produces
more optimally organised source code. This way, \NAME addresses the
heterogeneity of both the IoT and ID, as well as the limited resources of IoT
devices. A side-by-side comparison shows that generated code reduces memory
footprint, message passing overhead and execution time in comparison to a
straightforward sequential implementation of the same algorithms.

\end{abstract}

\section{Introduction}

% context

% IoT + threat

Along with its potential, the IoT also presents a significant threat: by
opening our smart homes \cite{aldrich2003smart} and personal data to all these
interconnected devices, we also open them to everyone who is able to break
these new, virtual locks, often without leaving a trace.

% classic networks: fw and central ids

In classic networks, firewalls focus on the outer perimeter of the network,
filtering unwanted packets and protecting the entire internal network. But
attacks on flaws in services can pass unnoticed. This is where intrusion
detection (ID) steps in: an ID probe monitors all traffic that passes through
the firewall, looking for patterns and optionally alerting the firewall if a
malicious pattern is detected \cite{denning1987intrusion}.

% manet: local ids -> localize -> limited resources

In mobile ad hoc networks (MANET), which make up an important part of the IoT,
it is not possible to have this single point in the network that can oversee
all traffic \cite{zhang2000intrusion, mishra2004intrusion}. If the outer
security perimeter diminishes, every device has to implement its own lines of
defence. Making the IDS a local service on each device requires resources,
which are another important constraint: IoT devices typically have limited
batteries, little processing power and memory is restricted to the bare minimum.

% gap analysis

Current developments in ID focus on programming frameworks to structure the
implementation of different algorithms \cite{valero2012di} and offer the
required basic functional components to implement actual algorithms
\cite{krontiris2008lidea}, but don't offer a way to optimise the usage of
resources. They also don't support systematic reuse to create different
configurations for different nodes or evolution in time.

% problem -> requirements for solution

The IoT is a heterogeneous environment, both in hardware and software.
Addressing this in a transparent and automated way is a key success factor for
any kind of development in this area. For a non-functional layer, such as ID,
this aspect becomes even more paramount.

A solution that supports the integration of multiple algorithms on IoT devices
needs to consider the impact on their resources. Different algorithms should be
merged to avoid accumulating their impact.

% my approach merged into ...
% scientific contribution

% 1. framework: language + code generator

The first contribution of this paper is a framework that enables the formal
description of ID algorithms on a functional level. An automated code
generation process produces corresponding source code, for a given platform and
configuration. This way, the framework addresses the heterogeneous nature of
both the IoT, as a hardware and software platform, and ID algorithms.

% 2. FCF to optimise

The second contribution introduces functional code fusion (FCF) as a generation
paradigm. FCF identifies common data and functions, and organises code in such
a way that redundant iterations, tests and computations are eliminated. Our
results show substantially improved memory usage, execution time and usage of
the wireless radio, reducing energy consumption.

% structure

The remainder of this paper proceeds as follows: section \ref{background}
details some of the ideas behind FCF and identifies the different aspects of
the problem space. Section \ref{design} describes the design we applied to
construct the framework, its domain specific language (DSL) and code generator.
Section \ref{evaluation} evaluates an implementation and application of the
framework. Section \ref{related} explores related work in the field of DSLs for
ID and code generation for the IoT. Finally, section \ref{conclusion}
summarises our findings, draws conclusions and identifies topics for future
work.

\section{Background}
\label{background}

The underlying problem addressed in this paper is of an economic nature: adding
ID doesn't add functionality, so its impact should be reduced as much as
possible.

In literature, many ID algorithm are described, but hardly any are implemented.
If implementations would be available, one would typically apply a pattern as
shown in listing \ref{alg:id-algo-application}.

\begin{figure}[H]
\begin{algorithmic}[1]
  \Let{$msg$}{$network$} \Comment{all observed messages}
  \ForEach{$algorithm \in algorithms$}
    \State \Call{algorithm.progress\_message}{msg}
  \EndFor
  \State \dots
  \Comment{at a given interval}
  \ForEach{$algorithm \in algorithms$}
    \State \Call{algorithm.do\_housekeeping}{}
  \EndFor
\end{algorithmic}
\captionof{listing}{Sequential implementation of several ID algorithms\label{alg:id-algo-application}}
\end{figure}

The implementations would be linked and called in a sequential way, when new
messages are observed on the network and at a regular interval to allow them to
do internal housekeeping. This includes processing the information extracted
from the network traffic, often in a statistical way.

This duality is a common design pattern of ID algorithms targeting MANETs. The
internals of the pattern reveal more common structures, as illustrated in
listing \ref{alg:id-algo-pattern}.

\begin{figure}[H]
\begin{algorithmic}[1]
  \Require{nodes, global storage for information about nodes}
  \Function{process\_message}{$msg$}
    \ForEach{$byte \in msg$} \label{alg:id-algo-pattern-loop1}
     \State \dots \Comment{analyse byte-sequences}
    \EndFor
    \Let{$nodes_x$}{value}  \Comment{optionally update node info}
    \State \Call{send}{$nodes_y$, ``info''} \Comment{optionally exchange info} \label{alg:id-algo-pattern-send1}
  \EndFunction
  \State
  \Function{do\_housekeeping}{}
    \ForEach{$node \in nodes$} \label{alg:id-algo-pattern-loop2} \label{alg:id-algo-pattern-common-data}
      \If{$node > \dots$} \Comment{validate recorded value}
        \State \dots \Comment{take actions}
        \State \Call{send}{$node$, ``info''} \Comment{e.g. communicate} \label{alg:id-algo-pattern-send2}
      \EndIf
    \EndFor
  \EndFunction
  \State
\end{algorithmic}
\captionof{listing}{ID Algorithm Pattern\label{alg:id-algo-pattern}}
\end{figure}

The parts of interest here are the loops at lines
\ref{alg:id-algo-pattern-loop1} and \ref{alg:id-algo-pattern-loop2}, the common
\emph{nodes} data on line \ref{alg:id-algo-pattern-common-data} and the
interaction with the network at lines \ref{alg:id-algo-pattern-send1} and
\ref{alg:id-algo-pattern-send2}.

\subsection{Loops and Common Data}

Given several ID algorithms, that all execute the same parsing loop, over the
same byte stream, performing comparable operations to find similar patterns,
one would clearly benefit from combining these loops, avoiding redundant
reevaluation of the same byte patterns.

The same goes for common data. Each algorithm not only has to parse the same
message, it also has to store information about nodes within its own scope,
resulting in a lot of duplicated information in memory.

The only way to solve this, would be to change the provided implementation,
pulling up the loops over the message and the nodes to a level above the loop
over the algorithms. But this comes at a development cost. This cost typically
isn't a one-time cost, e.g. in case a new version of the algorithm is released,
or simply when a different set of algorithms is selected due to a changing risk
analysis. Finally, changing, or simply implementing the algorithms from
scratch, also holds the risk of making mistakes.

\subsection{Network Usage}

But there are hardly any implementations readily available. Probably the main
reason for this is the heterogeneity of the IoT. A prime example is the
\ttt{SEND} function. Different software stacks will have different application
programming interfaces (APIs) for accessing the network. Simple, macro-like
solutions can overcome this, but the dispersion of the calls to access the
network is causing the wireless radio to be on a lot more that one would hope
for.

A valid solution would try to combine messages in a single instance, reducing
the access to the network and even sharing some network overhead. The impact to
implement this manually will again outweigh the gain. An option would be to use
a software library, that provides a unified API for accessing the network and
collects individual calls and combines them in a single network message.

Besides the fact that all researchers would have to use the same library in a
consistent way, they would limit their operational scope to a single language,
serving only a fraction of the heterogeneous IoT.

\subsection{Situation Summary}

Starting from scratch allows optimising the implementation of an IDS, but
doesn't scale. Reusing existing implementations also doesn't help, due to the
far from optimal sequential execution of the algorithms and the redundant
storage of common data. Software libraries can solve many of the issues, but
only cover parts of the entire spectrum, due to their tie-in with languages and
frameworks.

\section{Design}
\label{design}



\section{Implementation and Evaluation}
\label{evaluation}

network usages: number of packets, number of bytes

processing time

image size

TODO: memory usage ?

2 algorithms \cite{ganeriwal2008reputation}

TODO: add 3rd ? \cite{krontiris2009cooperative}

\section{Related Work}
\label{related}

IDS in WSN \cite{perrig2004security,mishra2004intrusion}

DSL \cite{fowler2010domain,mernik2005and}

DSL for WSN \cite{naumowicz2009prototyping,levis2004tinyscript}

DSL for IDS \cite{eckmann2002statl}

Code Generation for embedded systems/WSNs \cite{leupers2000code,marwedel2002code}

Code Optimization for embedded systems/WSNs \cite{panda2001data,naik2001software}

Code Generation for IDS \cite{charitakis2003code}

% manet: IDS algorithms -> coorporation, trust

More than in a classic network IDS, ID algorithms for MANETS operate with a
large degree of uncertainty. They often have to collaborate with other devices
in the network \cite{marchang2008collaborative,krontiris2009cooperative}, which
increases the level of uncertainty, because no other device can fully be
trusted. An IDS on an IoT device will be able to provide the services with
information about the reputation \cite{ganeriwal2008reputation} of other nodes
in the network.

\section{Conclusion and Future Work}
\label{conclusion}

theoretical gains are met in practice

explore more domains + implement corresponding DSLs for embedded systems

extract generic language as host for DSLs

Integration of applications with generated IDS allows actively and dynamically
responding to changes in the reputation of other nodes.

The services running on those devices can take advantage of these local
security layers. If the IDS detects a problem, the service can immediately
terminate the communication with the attacker, before it's actually abused.

\section*{Acknowledgements}

This research is partially funded by the Interuniversity Attraction Poles
Programme Belgian State, Belgian Science Policy, and by the Research Fund KU
Leuven. This research is partially funded by the EU FP7 project NESSoS. We
would like to thank the reviewers for their thoughtful and helpful comments
that enhanced the readability of this paper. Our gratitude and respect also
goes out to all members of the NES task force at KU Leuven/DistriNet for
creating the nurturing environment where these ideas could grow.

\bibliographystyle{IEEEtran}
\bibliography{literature/referenties}

\end{document}
